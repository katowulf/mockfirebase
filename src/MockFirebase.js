'use strict';

var DEBUG = false; // enable lots of console logging (best used while isolating one test case)

var _     = require('lodash');
var md5   = require('MD5');

/**
 * A mock that simulates Firebase operations for use in unit tests.
 *
 * ## Setup
 *
 *     // in windows
 *     <script src="lib/lodash.js"></script> <!-- dependency -->
 *     <script src="lib/MockFirebase.js"></script> <!-- the lib -->
 *     <script>
 *       // to override all calls to new Firebase:
 *       MockFirebase.override();
 *       // test units can be invoked now...
 *     </script>
 *
 *     // in node.js
 *     var Firebase = require('../lib/MockFirebase');
 *
 * ## Usage Examples
 *
 *     var fb = new MockFirebase('Mock://foo/bar');
 *     fb.on('value', function(snap) {
  *        console.log(snap.val());
  *     });
 *
 *     // do things async or synchronously, like fb.child('foo').set('bar')...
 *
 *     // trigger callbacks and event listeners
 *     fb.flush();
 *
 *     // spy on methods
 *     expect(fb.on.called).toBe(true);
 *
 * ## Trigger events automagically instead of calling flush()
 *
 *     var fb = new MockFirebase('Mock://hello/world');
 *     fb.autoFlush(1000); // triggers events after 1 second (asynchronous)
 *     fb.autoFlush(); // triggers events immediately (synchronous)
 *
 * ## Simulating Errors
 *
 *     var fb = new MockFirebase('Mock://fails/a/lot');
 *     fb.failNext('set', new Error('PERMISSION_DENIED'); // create an error to be invoked on the next set() op
 *     fb.set({foo: bar}, function(err) {
 *         // err.message === 'PERMISSION_DENIED'
 *     });
 *     fb.flush();
 *
 * ## Building with custom data
 *
 *     // change data for all mocks
 *     MockFirebase.DEFAULT_DATA = {foo: { bar: 'baz'}};
 *     var fb = new MockFirebase('Mock://foo');
 *     fb.once('value', function(snap) {
 *        snap.name(); // foo
 *        snap.val(); //  {bar: 'baz'}
 *     });
 *
 *     // customize for a single instance
 *     var fb = new MockFirebase('Mock://foo', {foo: 'bar'});
 *     fb.once('value', function(snap) {
 *        snap.name(); // foo
 *        snap.val(); //  'bar'
 *     });
 *
 * @param {string} [currentPath] use a relative path here or a url, all .child() calls will append to this
 * @param {Object} [data] specify the data in this Firebase instance (defaults to MockFirebase.DEFAULT_DATA)
 * @param {MockFirebase} [parent] for internal use
 * @param {string} [name] for internal use
 * @constructor
 */
function MockFirebase(currentPath, data, parent, name) {
  // represents the fake url
  //todo should unwrap nested paths; Firebase
  //todo accepts sub-paths, mock should too
  this.currentPath = currentPath || 'Mock://';

  // see failNext()
  this.errs = {};

  // used for setPriorty and moving records
  this.priority = null;

  // null for the root path
  this.myName = parent? name : extractName(currentPath);

  // see autoFlush() and flush()
  this.flushDelay = parent? parent.flushDelay : false;
  this.flushQueue = parent? parent.flushQueue : new FlushQueue();

  // stores the listeners for various event types
  this._events = { value: [], child_added: [], child_removed: [], child_changed: [], child_moved: [] };

  // allows changes to be propagated between child/parent instances
  this.parentRef = parent||null;
  this.children = {};
  if (parent) parent.children[this.name()] = this;

  // stores sorted keys in data for priority ordering
  this.sortedDataKeys = [];

  // do not modify this directly, use set() and flush(true)
  this.data = null;
  this._dataChanged(_.cloneDeep(arguments.length > 1? data||null : MockFirebase.DEFAULT_DATA));

  // stores the last auto id generated by push() for tests
  this._lastAutoId = null;

  // turn all our public methods into spies so they can be monitored for calls and return values
  // see jasmine spies: https://github.com/pivotal/jasmine/wiki/Spies
  // the Firebase constructor can be spied on using spyOn(window, 'Firebase') from within the test unit
  for(var key in this) {
    if( !key.match(/^_/) && typeof(this[key]) === 'function' ) {
      spyFactory(this, key);
    }
  }
}

MockFirebase.prototype = {
  /*****************************************************
   * Test Unit tools (not part of Firebase API)
   *****************************************************/

  /**
   * Invoke all the operations that have been queued thus far. If a numeric delay is specified, this
   * occurs asynchronously. Otherwise, it is a synchronous event.
   *
   * This allows Firebase to be used in synchronous tests without waiting for async callbacks. It also
   * provides a rudimentary mechanism for simulating locally cached data (events are triggered
   * synchronously when you do on('value') or on('child_added') against locally cached data)
   *
   * If you call this multiple times with different delay values, you could invoke the events out
   * of order; make sure that is your intention.
   *
   * This also affects all child and parent paths that were created using .child from the original
   * MockFirebase instance; all events queued before a flush, regardless of the node level in hierarchy,
   * are processed together. To make child and parent paths fire on a different timeline or out of order,
   * check out splitFlushQueue() below.
   *
   * <code>
   *   var fbRef = new MockFirebase();
   *   var childRef = fbRef.child('a');
   *   fbRef.update({a: 'foo'});
   *   childRef.set('bar');
   *   fbRef.flush(); // a === 'bar'
   *
   *   fbRef.update({a: 'foo'});
   *   fbRef.flush(0); // async flush
   *
   *   childRef.set('bar');
   *   childRef.flush(); // sync flush (could also do fbRef.flush()--same thing)
   *   // after the async flush completes, a === 'foo'!
   *   // the child_changed and value events also happen in reversed order
   * </code>
   *
   * @param {boolean|int} [delay]
   * @returns {MockFirebase}
   */
  flush: function(delay) {
    this.flushQueue.flush(delay);
    return this;
  },

  /**
   * Automatically trigger a flush event after each operation. If a numeric delay is specified, this is an
   * asynchronous event. If value is set to true, it is synchronous (flush is triggered immediately). Setting
   * this to false disables autoFlush
   *
   * @param {int|boolean} [delay]
   * @returns {MockFirebase}
   */
  autoFlush: function(delay){
    if(_.isUndefined(delay)) { delay = true; }
    if( this.flushDelay !== delay ) {
      this.flushDelay = delay;
      _.each(this.children, function(c) {
        c.autoFlush(delay);
      });
      if( this.parentRef ) { this.parentRef.autoFlush(delay); }
      if (delay !== false) this.flush(delay);
    }
    return this;
  },

  /**
   * If we can't use fakeEvent() and we need to test events out of order, we can give a child its own flush queue
   * so that calling flush() does not also trigger parent and siblings in the queue.
   */
  splitFlushQueue: function() {
    this.flushQueue = new FlushQueue();
  },

  /**
   * Restore the flush queue after using splitFlushQueue() so that child/sibling/parent queues are flushed in order.
   */
  joinFlushQueue: function() {
    if( this.parent ) {
      this.flushQueue = this.parent.flushQueue;
    }
  },

  /**
   * Simulate a failure by specifying that the next invocation of methodName should
   * fail with the provided error.
   *
   * @param {String} methodName currently only supports `set`, `update`, `push` (with data) and `transaction`
   * @param {String|Error} error
   */
  failNext: function(methodName, error) {
    this.errs[methodName] = error;
  },

  /**
   * Simulate a security error by cancelling any opened listeners on the given path
   * and returning the error provided. If event/callback/context are provided, then
   * only listeners exactly matching this signature (same rules as off()) will be cancelled.
   *
   * This also invokes off() on the events--they won't be notified of future changes.
   *
   * @param {String|Error} error
   * @param {String} [event]
   * @param {Function} [callback]
   * @param {Object} [context]
   */
  forceCancel: function(error, event, callback, context) {
    var self = this, events = self._events;
    _.each(event? [event] : _.keys(events), function(eventType) {
      var list = _.filter(events[eventType], function(parts) {
        return !event || !callback || (callback === parts[0] && context === parts[1]);
      });
      _.each(list, function(parts) {
        parts[2].call(parts[1], error);
        self.off(event, callback, context);
      });
    });
  },

  /**
   * Returns a copy of the current data
   * @returns {*}
   */
  getData: function() {
    return _.cloneDeep(this.data);
  },

  /**
   * Returns keys from the data in this path
   * @returns {Array}
   */
  getKeys: function() {
    return this.sortedDataKeys.slice();
  },

  /**
   * Returns the last automatically generated ID
   * @returns {string|string|*}
   */
  getLastAutoId: function() {
    return this._lastAutoId;
  },

  /**
   * Generates a fake event that does not affect or derive from the actual data in this
   * mock. Great for quick event handling tests that won't rely on longer-term consistency
   * or for creating out-of-order networking conditions that are hard to produce
   * using set/remove/setPriority
   *
   * @param {string} event
   * @param {string} key
   * @param data
   * @param {string} [prevChild]
   * @param [pri]
   * @returns {MockFirebase}
   */
  fakeEvent: function(event, key, data, prevChild, pri) {
    if (DEBUG) console.log('fakeEvent', event, this.toString(), key);
    if( arguments.length < 5 ) { pri = null; }
    if( arguments.length < 4 ) { prevChild = null; }
    if( arguments.length < 3 ) { data = null; }
    var self = this;
    var ref = event==='value'? self : self.child(key);
    var snap = makeSnap(ref, data, pri);
    self._defer(function() {
      _.each(self._events[event], function (parts) {
        var fn = parts[0], context = parts[1];
        if (_.contains(['child_added', 'child_moved'], event)) {
          fn.call(context, snap, prevChild);
        }
        else {
          fn.call(context, snap);
        }
      });
    });
    return this;
  },

  /*****************************************************
   * Firebase API methods
   *****************************************************/

  toString: function() {
    return this.currentPath;
  },

  child: function(childPath) {
    if( !childPath ) { throw new Error('bad child path '+this.toString()); }
    var parts = _.isArray(childPath)? childPath : _.compact(childPath.split('/'));
    var childKey = parts.shift();
    var child = this.children[childKey];
    if( !child ) {
      child = new MockFirebase(mergePaths(this.currentPath, childKey), this._childData(childKey), this, childKey);
      this.children[child.name()] = child;
    }
    if( parts.length ) {
      child = child.child(parts);
    }
    return child;
  },

  set: function(data, callback) {
    var self = this;
    var err = this._nextErr('set');
    data = _.cloneDeep(data);
    if (DEBUG) console.log('set called',this.toString(), data);
    this._defer(function() {
      if (DEBUG) console.log('set completed',self.toString(), data);
      if( err === null ) {
        self._dataChanged(data);
      }
      if (callback) callback(err);
    });
  },

  update: function(changes, callback) {
    if( !_.isObject(changes) ) {
      throw new Error('First argument must be an object when calling $update');
    }
    var self = this;
    var err = this._nextErr('update');
    var base = this.getData();
    var data = _.assign(_.isObject(base)? base : {}, changes);
    if (DEBUG) console.log('update called', this.toString(), data);
    this._defer(function() {
      if (DEBUG) console.log('update flushed', self.toString(), data);
      if( err === null ) {
        self._dataChanged(data);
      }
      if (callback) callback(err);
    });
  },

  setPriority: function(newPriority, callback) {
    var self = this;
    var err = this._nextErr('setPriority');
    if (DEBUG) console.log('setPriority called', self.toString(), newPriority);
    self._defer(function() {
      if (DEBUG) console.log('setPriority flushed', self.toString(), newPriority);
      self._priChanged(newPriority);
      if (callback) callback(err);
    });
  },

  setWithPriority: function(data, pri, callback) {
    this.setPriority(pri);
    this.set(data, callback);
  },

  name: function() {
    return this.myName;
  },

  ref: function() {
    return this;
  },

  parent: function() {
    return this.parentRef;
  },

  root: function() {
    var next = this;
    while(next.parentRef) {
      next = next.parentRef;
    }
    return next;
  },

  push: function(data, callback) {
    var child = this.child(this._newAutoId());
    var err = this._nextErr('push');
    if( err ) { child.failNext('set', err); }
    if( arguments.length && data !== null ) {
      // currently, callback only invoked if child exists
      child.set(data, callback);
    }
    return child;
  },

  once: function(event, callback, cancel, context) {
    var self = this;
    if( arguments.length === 3 && !_.isFunction(cancel) ) {
      context = cancel;
      cancel = function() {};
    }
    else if( arguments.length < 3 ) {
      cancel = function() {};
      context = null;
    }
    var err = this._nextErr('once');
    if( err ) {
      this._defer(function() {
        cancel.call(context, err);
      });
    }
    else {
      var fn = function (snap) {
        self.off(event, fn, context);
        callback.call(context, snap);
      };

      this.on(event, fn, context);
    }
  },

  remove: function(callback) {
    var self = this;
    var err = this._nextErr('remove');
    if (DEBUG) console.log('remove called', this.toString());
    this._defer(function() {
      if (DEBUG) console.log('remove completed',self.toString());
      if( err === null ) {
        self._dataChanged(null);
      }
      if (callback) callback(err);
    });
    return this;
  },

  on: function(event, callback, cancel, context) {
    if( arguments.length === 3 && !_.isFunction(cancel) ) {
      context = cancel;
      cancel = function() {};
    }
    else if( arguments.length < 3 ) {
      cancel = function() {};
    }

    var err = this._nextErr('on');
    if( err ) {
      this._defer(function() {
        cancel.call(context, err);
      });
    }
    else {
      var eventArr = [callback, context, cancel];
      this._events[event].push(eventArr);
      var self = this;
      if( event === 'value' ) {
        self._defer(function() {
          // make sure off() wasn't called in the interim
          if( self._events[event].indexOf(eventArr) > -1) {
            callback.call(context, makeSnap(self, self.getData(), self.priority));
          }
        });
      }
      else if( event === 'child_added' ) {
        self._defer(function() {
          if( self._events[event].indexOf(eventArr) > -1) {
            var prev = null;
            _.each(self.sortedDataKeys, function (k) {
              var child = self.child(k);
              callback.call(context, makeSnap(child, child.getData(), child.priority), prev);
              prev = k;
            });
          }
        });
      }
    }
  },

  off: function(event, callback, context) {
    if( !event ) {
      for (var key in this._events)
        if( this._events.hasOwnProperty(key) )
          this.off(key);
    }
    else if( callback ) {
      var list = this._events[event];
      var newList = this._events[event] = [];
      _.each(list, function(parts) {
        if( parts[0] !== callback || parts[1] !== context ) {
          newList.push(parts);
        }
      });
    }
    else {
      this._events[event] = [];
    }
  },

  transaction: function(valueFn, finishedFn, applyLocally) {
    var self = this;
    var valueSpy = spyFactory(valueFn, 'trxn:valueFn');
    var finishedSpy = spyFactory(finishedFn, 'trxn:finishedFn');
    this._defer(function() {
      var err = self._nextErr('transaction');
      // unlike most defer methods, self will use the value as it exists at the time
      // the transaction is actually invoked, which is the eventual consistent value
      // it would have in reality
      var res = valueSpy(self.getData());
      var newData = _.isUndefined(res) || err? self.getData() : res;
      self._dataChanged(newData);
      finishedSpy(err, err === null && !_.isUndefined(res), makeSnap(self, newData, self.priority));
    });
    return [valueSpy, finishedSpy, applyLocally];
  },

  /**
   * If token is valid and parses, returns the contents of token as exected. If not, the error is returned.
   * Does not change behavior in any way (since we don't really auth anywhere)
   *
   * @param {String} token
   * @param {Function} [callback]
   */
  auth: function(token, callback) {
    //todo invoke callback with the parsed token contents
    var err = this._nextErr('auth');
    if (callback) {
      this._defer(function() {
        var auth = { auth: { id: 'test', _token: token }, expires: (new Date()).to_i / 1000 };
        if( err === null ) {
          callback(null, auth);
        } else {
          callback(err);
        }
      });
    }
  },

  /**
   * Just a stub at this point.
   * @param {int} limit
   */
  limit: function(limit) {
    return new MockQuery(this).limit(limit);
  },

  startAt: function(priority, key) {
    return new MockQuery(this).startAt(priority, key);
  },

  endAt: function(priority, key) {
    return new MockQuery(this).endAt(priority, key);
  },

  /*****************************************************
   * Private/internal methods
   *****************************************************/

  _childChanged: function(ref) {
    var events = [];
    var childKey = ref.name();
    var data = ref.getData();
    if (DEBUG) console.log('_childChanged', this.toString() + ' -> ' + childKey, data);
    if( data === null ) {
      this._removeChild(childKey, events);
    }
    else {
      this._updateOrAdd(childKey, data, events);
    }
    this._triggerAll(events);
  },

  _dataChanged: function(unparsedData) {
    var self = this;
    var pri = getMeta(unparsedData, 'priority', self.priority);
    var data = cleanData(unparsedData);
    if( pri !== self.priority ) {
      self._priChanged(pri);
    }
    if( !_.isEqual(data, self.data) ) {
      if (DEBUG) console.log('_dataChanged', self.toString(), data);
      var oldKeys = _.keys(self.data).sort();
      var newKeys = _.keys(data).sort();
      var keysToRemove = _.difference(oldKeys, newKeys);
      var keysToChange = _.difference(newKeys, keysToRemove);
      var events = [];

      _.each(keysToRemove, function(key) {
        self._removeChild(key, events);
      });

      if(!_.isObject(data)) {
        events.push(false);
        self.data = data;
      }
      else {
        _.each(keysToChange, function(key) {
          self._updateOrAdd(key, unparsedData[key], events);
        });
      }

      // update order of my child keys
      self._resort();

      // trigger parent notifications after all children have
      // been processed
      self._triggerAll(events);
    }
  },

  _priChanged: function(newPriority) {
    if (DEBUG) console.log('_priChanged', this.toString(), newPriority);
    this.priority = newPriority;
    if( this.parentRef ) {
      this.parentRef._resort(this.name());
    }
  },

  _getPri: function(key) {
    return _.has(this.children, key)? this.children[key].priority : null;
  },

  _resort: function(childKeyMoved) {
    var self = this;
    self.sortedDataKeys.sort(self.childComparator.bind(self));
    // resort the data object to match our keys so value events return ordered content
    var oldDat = _.assign({}, self.data);
    _.each(oldDat, function(v,k) { delete self.data[k]; });
    _.each(self.sortedDataKeys, function(k) {
      self.data[k] = oldDat[k];
    });
    if( !_.isUndefined(childKeyMoved) && _.has(self.data, childKeyMoved) ) {
      self._trigger('child_moved', self.data[childKeyMoved], self._getPri(childKeyMoved), childKeyMoved);
    }
  },

  _addKey: function(newKey) {
    if(_.indexOf(this.sortedDataKeys, newKey) === -1) {
      this.sortedDataKeys.push(newKey);
      this._resort();
    }
  },

  _dropKey: function(key) {
    var i = _.indexOf(this.sortedDataKeys, key);
    if( i > -1 ) {
      this.sortedDataKeys.splice(i, 1);
    }
  },

  _defer: function() {
    //todo should probably be taking some sort of snapshot of my data here and passing
    //todo that into `fn` for reference
    this.flushQueue.add(Array.prototype.slice.call(arguments, 0));
    if( this.flushDelay !== false ) { this.flush(this.flushDelay); }
  },

  _trigger: function(event, data, pri, key) {
    if (DEBUG) console.log('_trigger', event, this.toString(), key);
    var self = this, ref = event==='value'? self : self.child(key);
    var snap = makeSnap(ref, data, pri);
    _.each(self._events[event], function(parts) {
      var fn = parts[0], context = parts[1];
      if(_.contains(['child_added', 'child_moved'], event)) {
        fn.call(context, snap, self._getPrevChild(key));
      }
      else {
        fn.call(context, snap);
      }
    });
  },

  _triggerAll: function(events) {
    var self = this;
    if( !events.length ) { return; }
    _.each(events, function(event) {
      if (event !== false) self._trigger.apply(self, event);
    });
    self._trigger('value', self.data, self.priority);
    if( self.parentRef ) {
      self.parentRef._childChanged(self);
    }
  },

  _updateOrAdd: function(key, data, events) {
    var exists = _.isObject(this.data) && this.data.hasOwnProperty(key);
    if( !exists ) {
      return this._addChild(key, data, events);
    }
    else {
      return this._updateChild(key, data, events);
    }
  },

  _addChild: function(key, data, events) {
    if(this._hasChild(key)) {
      throw new Error('Tried to add existing object', key);
    }
    if( !_.isObject(this.data) ) {
      this.data = {};
    }
    this._addKey(key);
    this.data[key] = cleanData(data);
    var c = this.child(key);
    c._dataChanged(data);
    if (events) events.push(['child_added', c.getData(), c.priority, key]);
  },

  _removeChild: function(key, events) {
    if(this._hasChild(key)) {
      this._dropKey(key);
      var data = this.data[key];
      delete this.data[key];
      if(_.isEmpty(this.data)) {
        this.data = null;
      }
      if(_.has(this.children, key)) {
        this.children[key]._dataChanged(null);
      }
      if (events) events.push(['child_removed', data, null, key]);
    }
  },

  _updateChild: function(key, data, events) {
    var cdata = cleanData(data);
    if(_.isObject(this.data) && _.has(this.data,key) && !_.isEqual(this.data[key], cdata)) {
      this.data[key] = cdata;
      var c = this.child(key);
      c._dataChanged(data);
      if (events) events.push(['child_changed', c.getData(), c.priority, key]);
    }
  },

  _newAutoId: function() {
    this._lastAutoId = 'mock-'+Date.now()+'-'+Math.floor(Math.random()*10000);
    return this._lastAutoId;
  },

  _nextErr: function(type) {
    var err = this.errs[type];
    delete this.errs[type];
    return err||null;
  },

  _hasChild: function(key) {
    return _.isObject(this.data) && _.has(this.data, key);
  },

  _childData: function(key) {
    return this._hasChild(key)? this.data[key] : null;
  },

  _getPrevChild: function(key) {
//      this._resort();
    var keys = this.sortedDataKeys;
    var i = _.indexOf(keys, key);
    if( i === -1 ) {
      keys = keys.slice();
      keys.push(key);
      keys.sort(this.childComparator.bind(this));
      i = _.indexOf(keys, key);
    }
    return i === 0? null : keys[i-1];
  },

  childComparator: function(a, b) {
    var aPri = this._getPri(a);
    var bPri = this._getPri(b);
    var x = priorityComparator(aPri, bPri);
    if( x === 0 ) {
      if( a !== b ) {
        x = a < b? -1 : 1;
      }
    }
    return x;
  }
};


/*******************************************************************************
 * MOCK QUERY
 ******************************************************************************/
function MockQuery(ref) {
  this._ref = ref;
  this._subs = [];
  // startPri, endPri, startKey, endKey, and limit
  this._q = {};
}

MockQuery.prototype = {
  /*******************
   * UTILITY FUNCTIONS
   *******************/
  flush: function() {
    this.ref().flush.apply(this.ref(), arguments);
    return this;
  },

  autoFlush: function() {
    this.ref().autoFlush.apply(this.ref(), arguments);
    return this;
  },

  slice: function() {
    return new Slice(this);
  },

  getData: function() {
    return this.slice().data;
  },

  fakeEvent: function(event, snap) {
    _.each(this._subs, function(parts) {
      if( parts[0] === 'event' ) {
        parts[1].call(parts[2], snap);
      }
    });
  },

  /*******************
   *   API FUNCTIONS
   *******************/
  on: function(event, callback, cancelCallback, context) {
    var self = this, isFirst = true, lastSlice = this.slice(), map;
    var fn = function(snap, prevChild) {
      var slice = new Slice(self, event==='value'? snap : makeRefSnap(snap.ref().parent()));
      switch(event) {
        case 'value':
          if( isFirst || !lastSlice.equals(slice) ) {
            callback.call(context, slice.snap());
          }
          break;
        case 'child_moved':
          var x = slice.pos(snap.name());
          var y = slice.insertPos(snap.name());
          if( x > -1 && y > -1 ) {
            callback.call(context, snap, prevChild);
          }
          else if( x > -1 || y > -1 ) {
            map = lastSlice.changeMap(slice);
          }
          break;
        case 'child_added':
          if( slice.has(snap.name()) && lastSlice.has(snap.name()) ) {
            // is a child_added for existing event so allow it
            callback.call(context, snap, prevChild);
          }
          map = lastSlice.changeMap(slice);
          break;
        case 'child_removed':
          map = lastSlice.changeMap(slice);
          break;
        case 'child_changed':
          callback.call(context, snap);
          break;
        default:
          throw new Error('Invalid event: '+event);
      }

      if( map ) {
        var newSnap = slice.snap();
        var oldSnap = lastSlice.snap();
        _.each(map.added, function(addKey) {
          self.fakeEvent('child_added', newSnap.child(addKey));
        });
        _.each(map.removed, function(remKey) {
          self.fakeEvent('child_removed', oldSnap.child(remKey));
        });
      }

      isFirst = false;
      lastSlice = slice;
    };
    var cancelFn = function(err) {
      cancelCallback.call(context, err);
    };
    self._subs.push([event, callback, context, fn]);
    this.ref().on(event, fn, cancelFn);
  },

  off: function(event, callback, context) {
    var ref = this.ref();
    _.each(this._subs, function(parts) {
      if( parts[0] === event && parts[1] === callback && parts[2] === context ) {
        ref.off(event, parts[3]);
      }
    });
  },

  once: function(event, callback, context) {
    var self = this;
    // once is tricky because we want the first match within our range
    // so we use the on() method above which already does the needed legwork
    function fn() {
      self.off(event, fn);
      // the snap is already sliced in on() so we can just pass it on here
      callback.apply(context, arguments);
    }
    self.on(event, fn);
  },

  limit: function(intVal) {
    if( typeof intVal !== 'number' ) {
      throw new Error('Query.limit: First argument must be a positive integer.');
    }
    var q = new MockQuery(this.ref());
    _.extend(q._q, this._q, {limit: intVal});
    return q;
  },

  startAt: function(priority, key) {
    assertQuery('Query.startAt', priority, key);
    var q = new MockQuery(this.ref());
    _.extend(q._q, this._q, {startKey: key, startPri: priority});
    return q;
  },

  endAt: function(priority, key) {
    assertQuery('Query.endAt', priority, key);
    var q = new MockQuery(this.ref());
    _.extend(q._q, this._q, {endKey: key, endPri: priority});
    return q;
  },

  ref: function() {
    return this._ref;
  }
};


/*******************************************************************************
 * SIMPLE LOGIN
 ******************************************************************************/
function MockFirebaseSimpleLogin(ref, callback, userData) {
  // allows test units to monitor the callback function to make sure
  // it is invoked (even if one is not declared)
  this.callback = function() { callback.apply(null, Array.prototype.slice.call(arguments, 0)); };
  this.attempts = [];
  this.failMethod = MockFirebaseSimpleLogin.DEFAULT_FAIL_WHEN;
  this.ref = ref; // we don't use ref for anything
  this.autoFlushTime = MockFirebaseSimpleLogin.DEFAULT_AUTO_FLUSH;
  this.userData = _.cloneDeep(MockFirebaseSimpleLogin.DEFAULT_USER_DATA);
  if (userData) _.assign(this.userData, userData);

  // turn all our public methods into spies so they can be monitored for calls and return values
  // see jasmine spies: https://github.com/pivotal/jasmine/wiki/Spies
  // the constructor can be spied on using spyOn(window, 'FirebaseSimpleLogin') from within the test unit
  for(var key in this) {
    if( !key.match(/^_/) && typeof(this[key]) === 'function' ) {
      spyFactory(this, key);
    }
  }
}

MockFirebaseSimpleLogin.prototype = {

  /*****************************************************
   * Test Unit Methods
   *****************************************************/

  /**
   * When this method is called, any outstanding login()
   * attempts will be immediately resolved. If this method
   * is called with an integer value, then the login attempt
   * will resolve asynchronously after that many milliseconds.
   *
   * @param {int|boolean} [milliseconds]
   * @returns {MockFirebaseSimpleLogin}
   */
  flush: function(milliseconds) {
    var self = this;
    if(_.isNumber(milliseconds) ) {
      setTimeout(self.flush.bind(self), milliseconds);
    }
    else {
      var attempts = self.attempts;
      self.attempts = [];
      _.each(attempts, function(x) {
        x[0].apply(self, x.slice(1));
      });
    }
    return self;
  },

  /**
   * Automatically queue the flush() event
   * each time login() is called. If this method
   * is called with `true`, then the callback
   * is invoked synchronously.
   *
   * If this method is called with an integer,
   * the callback is triggered asynchronously
   * after that many milliseconds.
   *
   * If this method is called with false, then
   * autoFlush() is disabled.
   *
   * @param {int|boolean} [milliseconds]
   * @returns {MockFirebaseSimpleLogin}
   */
  autoFlush: function(milliseconds) {
    this.autoFlushTime = milliseconds;
    if( this.autoFlushTime !== false ) {
      this.flush(this.autoFlushTime);
    }
    return this;
  },

  /**
   * `testMethod` is passed the {string}provider, {object}options, {object}user
   * for each call to login(). If it returns anything other than
   * null, then that is passed as the error message to the
   * callback and the login call fails.
   *
   * <code>
   *   // this is a simplified example of the default implementation (MockFirebaseSimpleLogin.DEFAULT_FAIL_WHEN)
   *   auth.failWhen(function(provider, options, user) {
   *      if( user.email !== options.email ) {
   *         return MockFirebaseSimpleLogin.createError('INVALID_USER');
   *      }
   *      else if( user.password !== options.password ) {
   *         return MockFirebaseSimpleLogin.createError('INVALID_PASSWORD');
   *      }
   *      else {
   *         return null;
   *      }
   *   });
   * </code>
   *
   * Multiple calls to this method replace the old failWhen criteria.
   *
   * @param testMethod
   * @returns {MockFirebaseSimpleLogin}
   */
  failWhen: function(testMethod) {
    this.failMethod = testMethod;
    return this;
  },

  /**
   * Retrieves a user account from the mock user data on this object
   *
   * @param provider
   * @param options
   */
  getUser: function(provider, options) {
    var data = this.userData[provider];
    if( provider === 'password' ) {
      data = (data||{})[options.email];
    }
    return data||null;
  },

  /*****************************************************
   * Public API
   *****************************************************/
  login: function(provider, options) {
    var err = this.failMethod(provider, options||{}, this.getUser(provider, options));
    this._notify(err, err===null? this.userData[provider]: null);
  },

  logout: function() {
    this._notify(null, null);
  },

  createUser: function(email, password, callback) {
    if (!callback) callback = _.noop;
    this._defer(function() {
      var user = null, err = null;
      if( this.userData.password.hasOwnProperty(email) ) {
        err = createError('EMAIL_TAKEN', 'The specified email address is already in use.');
      }
      else {
        user = createEmailUser(email, password);
        this.userData.password[email] = user;
      }
      callback(err, user);
    });
  },

  changePassword: function(email, oldPassword, newPassword, callback) {
    if (!callback) callback = _.noop;
    this._defer(function() {
      var user = this.getUser('password', {email: email});
      var err = this.failMethod('password', {email: email, password: oldPassword}, user);
      if( err ) {
        callback(err, false);
      }
      else {
        user.password = newPassword;
        callback(null, true);
      }
    });
  },

  sendPasswordResetEmail: function(email, callback) {
    if (!callback) callback = _.noop;
    this._defer(function() {
      var user = this.getUser('password', {email: email});
      if( !user ) {
        callback(createError('INVALID_USER'), false);
      }
      else {
        callback(null, true);
      }
    });
  },

  removeUser: function(email, password, callback) {
    if (!callback) callback = _.noop;
    this._defer(function() {
      var user = this.getUser('password', {email: email});
      if( !user ) {
        callback(createError('INVALID_USER'), false);
      }
      else if( user.password !== password ) {
        callback(createError('INVALID_PASSWORD'), false);
      }
      else {
        delete this.userData.password[email];
        callback(null, true);
      }
    });
  },

  /*****************************************************
   * Private/internal methods
   *****************************************************/
  _notify: function(error, user) {
    this._defer(this.callback, error, user);
  },

  _defer: function() {
    var args = _.toArray(arguments);
    this.attempts.push(args);
    if( this.autoFlushTime !== false ) {
      this.flush(this.autoFlushTime);
    }
  }
};

/***
 * DATA SLICE
 * A utility to handle limits, startAts, and endAts
 */
function Slice(queue, snap) {
  var data = snap? snap.val() : queue.ref().getData();
  this.ref = snap? snap.ref() : queue.ref();
  this.priority = snap? snap.getPriority() : this.ref.priority;
  this.pris = {};
  this.data = {};
  this.map = {};
  this.outerMap = {};
  this.keys = [];
  this.props = this._makeProps(queue._q, this.ref, this.ref.getKeys().length);
  this._build(this.ref, data);
}

Slice.prototype = {
  prev: function(key) {
    var pos = this.pos(key);
    if( pos === 0 ) { return null; }
    else {
      if( pos < 0 ) { pos = this.keys.length; }
      return this.keys[pos-1];
    }
  },

  equals: function(slice) {
    return _.isEqual(this.keys, slice.keys) && _.isEqual(this.data, slice.data);
  },

  pos: function(key) {
    return this.has(key)? this.map[key] : -1;
  },

  insertPos: function(prevChild) {
    var outerPos = this.outerMap[prevChild];
    if( outerPos >= this.min && outerPos < this.max ) {
      return outerPos+1;
    }
    return -1;
  },

  has: function(key) {
    return this.map.hasOwnProperty(key);
  },

  snap: function(key) {
    var ref = this.ref;
    var data = this.data;
    var pri = this.priority;
    if( key ) {
      data = this.get(key);
      ref = ref.child(key);
      pri = this.pri(key);
    }
    return makeSnap(ref, data, pri);
  },

  get: function(key) {
    return this.has(key)? this.data[key] : null;
  },

  pri: function(key) {
    return this.has(key)? this.pris[key] : null;
  },

  changeMap: function(slice) {
    var self = this;
    var changes = { in: [], out: [] };
    _.each(self.data, function(v,k) {
      if( !slice.has(k) ) {
        changes.out.push(k);
      }
    });
    _.each(slice.data, function(v,k) {
      if( !self.has(k) ) {
        changes.in.push(k);
      }
    });
    return changes;
  },

  _inRange: function(props, key, pri, pos) {
    if( pos === -1 ) { return false; }
    if( !_.isUndefined(props.startPri) && priorityComparator(pri, props.startPri) < 0 ) {
      return false;
    }
    if( !_.isUndefined(props.startKey) && priorityComparator(key, props.startKey) < 0 ) {
      return false;
    }
    if( !_.isUndefined(props.endPri) && priorityComparator(pri, props.endPri) > 0 ) {
      return false;
    }
    if( !_.isUndefined(props.endKey) && priorityComparator(key, props.endKey) > 0 ) {
      return false;
    }
    if( props.max > -1 && pos > props.max ) {
      return false;
    }
    return pos >= props.min;
  },

  _findPos: function(pri, key, ref, isStartBoundary) {
    var keys = ref.getKeys(), firstMatch = -1, lastMatch = -1;
    var len = keys.length, i, x, k;
    if(_.isUndefined(pri) && _.isUndefined(key)) {
      return -1;
    }
    for(i = 0; i < len; i++) {
      k = keys[i];
      x = priAndKeyComparator(pri, key, ref.child(k).priority, k);
      if( x === 0 ) {
        // if the key is undefined, we may have several matching comparisons
        // so we will record both the first and last successful match
        if (firstMatch === -1) {
          firstMatch = i;
        }
        lastMatch = i;
      }
      else if( x < 0 ) {
        // we found the breakpoint where our keys exceed the match params
        if( i === 0 ) {
          // if this is 0 then our match point is before the data starts, we
          // will use len here because -1 already has a special meaning (no limit)
          // and len ensures we won't get any data (no matches)
          i = len;
        }
        break;
      }
    }

    if( firstMatch !== -1 ) {
      // we found a match, life is simple
      return isStartBoundary? firstMatch : lastMatch;
    }
    else if( i < len ) {
      // if we're looking for the start boundary then it's the first record after
      // the breakpoint. If we're looking for the end boundary, it's the last record before it
      return isStartBoundary? i : i -1;
    }
    else {
      // we didn't find one, so use len (i.e. after the data, no results)
      return len;
    }
  },

  _makeProps: function(queueProps, ref, numRecords) {
    var out = {};
    _.each(queueProps, function(v,k) {
      if(!_.isUndefined(v)) {
        out[k] = v;
      }
    });
    out.min = this._findPos(out.startPri, out.startKey, ref, true);
    out.max = this._findPos(out.endPri, out.endKey, ref);
    if( !_.isUndefined(queueProps.limit) ) {
      if( out.min > -1 ) {
        out.max = out.min + queueProps.limit;
      }
      else if( out.max > -1 ) {
        out.min = out.max - queueProps.limit;
      }
      else if( queueProps.limit < numRecords ) {
        out.max = numRecords-1;
        out.min = Math.max(0, numRecords - queueProps.limit);
      }
    }
    return out;
  },

  _build: function(ref, rawData) {
    var i = 0, map = this.map, keys = this.keys, outer = this.outerMap;
    var props = this.props, slicedData = this.data;
    _.each(rawData, function(v,k) {
      outer[k] = i < props.min? props.min - i : i - Math.max(props.min,0);
      if( this._inRange(props, k, ref.child(k).priority, i++) ) {
        map[k] = keys.length;
        keys.push(k);
        slicedData[k] = v;
      }
    }, this);
  }
};

/***
 * FLUSH QUEUE
 * A utility to make sure events are flushed in the order
 * they are invoked.
 ***/
function FlushQueue() {
  this.queuedEvents = [];
}

FlushQueue.prototype.add = function(args) {
  this.queuedEvents.push(args);
};

FlushQueue.prototype.flush = function(delay) {
  if( !this.queuedEvents.length ) { return; }

  // make a copy of event list and reset, this allows
  // multiple calls to flush to queue various events out
  // of order, and ensures that events that are added
  // while flushing go into the next flush and not this one
  var list = this.queuedEvents;

  // events could get added as we invoke
  // the list, so make a copy and reset first
  this.queuedEvents = [];

  function process() {
    // invoke each event
    list.forEach(function(parts) {
      parts[0].apply(null, parts.slice(1));
    });
  }

  if( _.isNumber(delay) ) {
    setTimeout(process, delay);
  }
  else {
    process();
  }
};


function priAndKeyComparator(testPri, testKey, valPri, valKey) {
  var x = 0;
  if( !_.isUndefined(testPri) ) {
    x = priorityComparator(testPri, valPri);
  }
  if( x === 0 && !_.isUndefined(testKey) && testKey !== valKey ) {
    x = testKey < valKey? -1 : 1;
  }
  return x;
}

function priorityComparator(a,b) {
  if (a !== b) {
    if( a === null || b === null ) {
      return a === null? -1 : 1;
    }
    if (typeof a !== typeof b) {
      return typeof a === 'number' ? -1 : 1;
    } else {
      return a > b ? 1 : -1;
    }
  }
  return 0;
}

var spyFactory = (function() {
  var spyFunction;
  if( typeof(global.jasmine) !== 'undefined' ) {
    spyFunction = function(obj, method) {
      var fn, spy;
      if( typeof(obj) === 'object' ) {
        spy = global.spyOn(obj, method);
        if( typeof(spy.andCallThrough) === 'function' ) {
          // karma < 0.12.x
          fn = spy.andCallThrough();
        }
        else {
          fn = spy.and.callThrough();
        }
      }
      else {
        spy = global.jasmine.createSpy(method);
        if( typeof(arguments[0]) === 'function' ) {
          if( typeof(spy.andCallFake) === 'function' ) {
            // karma < 0.12.x
            fn = spy.andCallFake(obj);
          }
          else {
            fn = spy.and.callFake(obj);
          }
        }
        else {
          fn = spy;
        }
      }
      return fn;
    };
  }
  else {
    spyFunction = function(obj, method) {
      var sinon = require('sinon');
      if ( typeof (obj) === 'object') {
        return sinon.spy(obj, method);
      }
      else {
        return sinon.spy(obj);
      }
    };
  }
  return spyFunction;
})();

var USER_COUNT = 100;
function createEmailUser(email, password) {
  var id = USER_COUNT++;
  return {
    uid: 'password:'+id,
    id: id,
    email: email,
    password: password,
    provider: 'password',
    md5_hash: md5(email),
    firebaseAuthToken: 'FIREBASE_AUTH_TOKEN' //todo
  };
}

function createDefaultUser(provider) {
  var id = USER_COUNT++;

  var out = {
    uid: provider+':'+id,
    id: id,
    password: id,
    provider: provider,
    firebaseAuthToken: 'FIREBASE_AUTH_TOKEN' //todo
  };
  switch(provider) {
    case 'password':
      out.email = 'email@firebase.com';
      out.md5_hash = md5(out.email);
      break;
    case 'twitter':
      out.accessToken = 'ACCESS_TOKEN'; //todo
      out.accessTokenSecret = 'ACCESS_TOKEN_SECRET'; //todo
      out.displayName = 'DISPLAY_NAME';
      out.thirdPartyUserData = {}; //todo
      out.username = 'USERNAME';
      break;
    case 'google':
      out.accessToken = 'ACCESS_TOKEN'; //todo
      out.displayName = 'DISPLAY_NAME';
      out.email = 'email@firebase.com';
      out.thirdPartyUserData = {}; //todo
      break;
    case 'github':
      out.accessToken = 'ACCESS_TOKEN'; //todo
      out.displayName = 'DISPLAY_NAME';
      out.thirdPartyUserData = {}; //todo
      out.username = 'USERNAME';
      break;
    case 'facebook':
      out.accessToken = 'ACCESS_TOKEN'; //todo
      out.displayName = 'DISPLAY_NAME';
      out.thirdPartyUserData = {}; //todo
      break;
    case 'anonymous':
      break;
    default:
      throw new Error('Invalid auth provider', provider);
  }

  return out;
}

function ref(path, autoSyncDelay) {
  var reference = new MockFirebase();
  reference.flushDelay = _.isUndefined(autoSyncDelay)? true : autoSyncDelay;
  if( path ) { reference = reference.child(path); }
  return reference;
}

function mergePaths(base, add) {
  return base.replace(/\/$/, '')+'/'+add.replace(/^\//, '');
}

function makeRefSnap(ref) {
  return makeSnap(ref, ref.getData(), ref.priority);
}

function makeSnap(ref, data, pri) {
  data = _.cloneDeep(data);
  if(_.isObject(data) && _.isEmpty(data)) { data = null; }
  return {
    val: function() { return data; },
    ref: function() { return ref; },
    name: function() { return ref.name(); },
    getPriority: function() { return pri; },
    forEach: function(cb, scope) {
      var self = this;
      _.each(data, function(v, k) {
        var res = cb.call(scope, self.child(k));
        return res !== true;
      });
    },
    child: function(key) {
      return makeSnap(ref.child(key), _.isObject(data) && _.has(data, key)? data[key] : null, ref.child(key).priority);
    }
  };
}

function extractName(path) {
  return ((path || '').match(/\/([^.$\[\]#\/]+)$/)||[null, null])[1];
}

function createError(code, message) {
  return { code: code||'UNKNOWN_ERROR', message: 'FirebaseSimpleLogin: '+(message||code||'unspecific error') };
}

function getMeta(data, key, defaultVal) {
  var val = defaultVal;
  var metaKey = '.' + key;
  if( _.isObject(data) && _.has(data, metaKey) ) {
    val = data[metaKey];
    delete data[metaKey];
  }
  return val;
}

function cleanData(data) {
  var newData = _.clone(data);
  if(_.isObject(newData)) {
    if(_.has(newData, '.value')) {
      newData = _.clone(newData['.value']);
    }
    if(_.has(newData, '.priority')) {
      delete newData['.priority'];
    }
//      _.each(newData, function(v,k) {
//        newData[k] = cleanData(v);
//      });
    if(_.isEmpty(newData)) { newData = null; }
  }
  return newData;
}

function assertKey(method, key, argNum) {
  if (!argNum) argNum = 'first';
  if( typeof(key) !== 'string' || key.match(/[.#$\/\[\]]/) ) {
    throw new Error(method + ' failed: '+argNum+' was an invalid key "'+(key+'')+'. Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
  }
}

function assertQuery(method, pri, key) {
  if( pri !== null && typeof(pri) !== 'string' && typeof(pri) !== 'number' ) {
    throw new Error(method + ' failed: first argument must be a valid firebase priority (a string, number, or null).');
  }
  if(!_.isUndefined(key)) {
    assertKey(method, key, 'second');
  }
}

/*** PUBLIC METHODS AND FIXTURES ***/

MockFirebaseSimpleLogin.DEFAULT_FAIL_WHEN = function(provider, options, user) {
  var res = null;
  if( ['password', 'anonymous', 'twitter', 'facebook', 'google', 'github'].indexOf(provider) === -1 ) {
    console.error('MockFirebaseSimpleLogin:login() failed: unrecognized authentication provider '+provider);
//      res = createError();
  }
  else if( !user ) {
    res = createError('INVALID_USER', 'The specified user does not exist');
  }
  else if( provider === 'password' && user.password !== options.password ) {
    res = createError('INVALID_PASSWORD', 'The specified password is incorrect');
  }
  return res;
};

MockFirebaseSimpleLogin.DEFAULT_USER_DATA = {};
_.each(['password', 'anonymous', 'facebook', 'twitter', 'google', 'github'], function(provider) {
  var user = createDefaultUser(provider);
  if( provider !== 'password' ) {
    MockFirebaseSimpleLogin.DEFAULT_USER_DATA[provider] = user;
  }
  else {
    var set = MockFirebaseSimpleLogin.DEFAULT_USER_DATA[provider] = {};
    set[user.email] = user;
  }
});


MockFirebase.md5 = md5;
MockFirebaseSimpleLogin.DEFAULT_AUTO_FLUSH = false;

MockFirebase._ = _; // expose for tests
MockFirebase.Query = MockQuery; // expose for tests

MockFirebase.override = function () {
  /* global window */
  if (typeof window !== 'undefined') {
    MockFirebase._origFirebase = window.Firebase;
    MockFirebase._origFirebaseSimpleLogin = window.FirebaseSimpleLogin;
    window.Firebase = MockFirebase;
    window.FirebaseSimpleLogin = MockFirebaseSimpleLogin;
  }
  else {
    console.warn('MockFirebase.override is only useful in a browser environment.');
  }
};

MockFirebase.ref = ref;
MockFirebase.DEFAULT_DATA  = {
  'data': {
    'a': {
      aString: 'alpha',
      aNumber: 1,
      aBoolean: false
    },
    'b': {
      aString: 'bravo',
      aNumber: 2,
      aBoolean: true
    },
    'c': {
      aString: 'charlie',
      aNumber: 3,
      aBoolean: true
    },
    'd': {
      aString: 'delta',
      aNumber: 4,
      aBoolean: true
    },
    'e': {
      aString: 'echo',
      aNumber: 5
    }
  },
  'index': {
    'b': true,
    'c': 1,
    'e': false,
    'z': true // must not exist in `data`
  },
  'ordered': {
    'null_a': {
      aNumber: 0,
      aLetter: 'a'
    },
    'null_b': {
      aNumber: 0,
      aLetter: 'b'
    },
    'null_c': {
      aNumber: 0,
      aLetter: 'c'
    },
    'num_1_a': {
      '.priority': 1,
      aNumber: 1
    },
    'num_1_b': {
      '.priority': 1,
      aNumber: 1
    },
    'num_2': {
      '.priority': 2,
      aNumber: 2
    },
    'num_3': {
      '.priority': 3,
      aNumber: 3
    },
    'char_a_1': {
      '.priority': 'a',
      aNumber: 1,
      aLetter: 'a'
    },
    'char_a_2': {
      '.priority': 'a',
      aNumber: 2,
      aLetter: 'a'
    },
    'char_b': {
      '.priority': 'b',
      aLetter: 'b'
    },
    'char_c': {
      '.priority': 'c',
      aLetter: 'c'
    }
  }
};

exports.MockFirebase = MockFirebase;
exports.MockFirebaseSimpleLogin = MockFirebaseSimpleLogin;
